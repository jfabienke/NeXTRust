diff --git a/llvm/lib/Target/M68k/MCTargetDesc/CMakeLists.txt b/llvm/lib/Target/M68k/MCTargetDesc/CMakeLists.txt
index 1127b3b54..2eef12f18 100644
--- a/llvm/lib/Target/M68k/MCTargetDesc/CMakeLists.txt
+++ b/llvm/lib/Target/M68k/MCTargetDesc/CMakeLists.txt
@@ -1,6 +1,7 @@
 add_llvm_component_library(LLVMM68kDesc
   M68kAsmBackend.cpp
   M68kELFObjectWriter.cpp
+  M68kMachObjectWriter.cpp
   M68kInstPrinter.cpp
   M68kMCAsmInfo.cpp
   M68kMCCodeEmitter.cpp
diff --git a/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp b/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
index b66557ec6..7154c5bca 100644
--- a/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
+++ b/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp
@@ -229,6 +229,18 @@ public:
   }
 };
 
+class M68kMachOAsmBackend : public M68kAsmBackend {
+public:
+  M68kMachOAsmBackend(const Target &T) : M68kAsmBackend(T) {}
+
+  std::unique_ptr<MCObjectTargetWriter>
+  createObjectTargetWriter() const override {
+    // NeXTSTEP uses CPU_TYPE_MC680x0 (6) and CPU_SUBTYPE_MC68030 (1) or CPU_SUBTYPE_MC68040 (2)
+    return createM68kMachObjectWriter(/*Is32Bit=*/true, /*CPUType=*/6, 
+                                      /*CPUSubtype=*/1);
+  }
+};
+
 } // end anonymous namespace
 
 MCAsmBackend *llvm::createM68kAsmBackend(const Target &T,
@@ -236,6 +248,15 @@ MCAsmBackend *llvm::createM68kAsmBackend(const Target &T,
                                          const MCRegisterInfo &MRI,
                                          const MCTargetOptions &Options) {
   const Triple &TheTriple = STI.getTargetTriple();
+  
+  // Check for NeXTSTEP/Mach-O
+  if (TheTriple.isOSBinFormatMachO() || 
+      TheTriple.getOS() == Triple::Darwin ||  // Handle darwin as Mach-O too
+      TheTriple.getOSName() == "nextstep") {  // Explicit check for nextstep
+    return new M68kMachOAsmBackend(T);
+  }
+  
+  // Default to ELF
   uint8_t OSABI = MCELFObjectTargetWriter::getOSABI(TheTriple.getOS());
   return new M68kELFAsmBackend(T, OSABI);
 }
diff --git a/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.h b/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.h
index 2a1cc6780..793e9afee 100644
--- a/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.h
+++ b/llvm/lib/Target/M68k/MCTargetDesc/M68kMCTargetDesc.h
@@ -17,6 +17,7 @@
 #include "llvm/MC/MCInstrDesc.h"
 #include "llvm/MC/MCObjectWriter.h"
 #include "llvm/Support/DataTypes.h"
+#include <memory>
 
 namespace llvm {
 class MCAsmBackend;
@@ -43,6 +44,10 @@ MCCodeEmitter *createM68kMCCodeEmitter(const MCInstrInfo &MCII,
 /// Construct an M68k ELF object writer.
 std::unique_ptr<MCObjectTargetWriter> createM68kELFObjectWriter(uint8_t OSABI);
 
+/// Construct an M68k Mach-O object writer.
+std::unique_ptr<MCObjectTargetWriter>
+createM68kMachObjectWriter(bool Is32Bit, uint32_t CPUType, uint32_t CPUSubtype);
+
 } // namespace llvm
 
 // Defines symbolic names for M68k registers. This defines a mapping from
diff --git a/llvm/lib/Target/M68k/MCTargetDesc/M68kMachObjectWriter.cpp b/llvm/lib/Target/M68k/MCTargetDesc/M68kMachObjectWriter.cpp
new file mode 100644
index 000000000..1bac574cc
--- /dev/null
+++ b/llvm/lib/Target/M68k/MCTargetDesc/M68kMachObjectWriter.cpp
@@ -0,0 +1,116 @@
+//===-- M68kMachObjectWriter.cpp - M68k Mach-O Object Writer -------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the M68k specific support for writing Mach-O object
+// files. This is specifically designed for NeXTSTEP support on M68k.
+//
+//===----------------------------------------------------------------------===//
+
+#include "MCTargetDesc/M68kFixupKinds.h"
+#include "MCTargetDesc/M68kMCTargetDesc.h"
+#include "llvm/BinaryFormat/MachO.h"
+#include "llvm/MC/MCAssembler.h"
+#include "llvm/MC/MCAsmLayout.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCFixup.h"
+#include "llvm/MC/MCFragment.h"
+#include "llvm/MC/MCMachObjectWriter.h"
+#include "llvm/MC/MCSection.h"
+#include "llvm/MC/MCSectionMachO.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/MC/MCValue.h"
+#include "llvm/Support/ErrorHandling.h"
+
+using namespace llvm;
+
+namespace {
+class M68kMachObjectWriter : public MCMachObjectTargetWriter {
+public:
+  M68kMachObjectWriter(bool Is32Bit, uint32_t CPUType, uint32_t CPUSubtype)
+      : MCMachObjectTargetWriter(Is32Bit, CPUType, CPUSubtype) {}
+
+  void recordRelocation(MachObjectWriter *Writer, MCAssembler &Asm,
+                        const MCAsmLayout &Layout, const MCFragment *Fragment,
+                        const MCFixup &Fixup, MCValue Target,
+                        uint64_t &FixedValue) override;
+};
+} // end anonymous namespace
+
+void M68kMachObjectWriter::recordRelocation(MachObjectWriter *Writer,
+                                             MCAssembler &Asm,
+                                             const MCAsmLayout &Layout,
+                                             const MCFragment *Fragment,
+                                             const MCFixup &Fixup,
+                                             MCValue Target,
+                                             uint64_t &FixedValue) {
+  const MCSymbol *A = &Target.getSymA()->getSymbol();
+  const MCSection *Section = Fragment->getParent();
+  
+  bool IsPCRel = Writer->isFixupKindPCRel(Asm, Fixup.getKind());
+  uint32_t FixupOffset = Layout.getFragmentOffset(Fragment) + Fixup.getOffset();
+  unsigned Log2Size = getFixupKindLog2Size(Fixup.getKind());
+  uint32_t FixupAddress = Writer->getFragmentAddress(Fragment, Layout) + Fixup.getOffset();
+
+  // NeXTSTEP uses scattered relocations for certain cases
+  bool UseScattered = false;
+  
+  // Handle scattered relocations for 32-bit symbol differences (common in switch tables)
+  if (Target.getSymB()) {
+    const MCSymbol *B = &Target.getSymB()->getSymbol();
+    const MCSection *SecB = &B->getSection();
+    
+    if (SecB != Section) {
+      // Cross-section references require scattered relocations
+      UseScattered = true;
+    }
+  }
+
+  if (UseScattered) {
+    // Create a scattered relocation entry for NeXTSTEP
+    MachO::any_relocation_info MRE;
+    MRE.r_word0 = FixupAddress;
+    MRE.r_word1 = (IsPCRel << 30) |
+                  (Log2Size << 28) |
+                  (MachO::GENERIC_RELOC_VANILLA << 24) |
+                  (1 << 31); // R_SCATTERED flag
+    
+    Writer->addRelocation(A, Section, MRE);
+  } else {
+    // Standard relocation
+    unsigned Type = MachO::GENERIC_RELOC_VANILLA;
+    
+    // Determine relocation type based on fixup
+    switch (Fixup.getKind()) {
+    default:
+      report_fatal_error("Unimplemented fixup type for M68k Mach-O");
+    case FK_Data_1:
+    case FK_Data_2:
+    case FK_Data_4:
+      Type = MachO::GENERIC_RELOC_VANILLA;
+      break;
+    case FK_PCRel_1:
+    case FK_PCRel_2:
+    case FK_PCRel_4:
+      Type = MachO::GENERIC_RELOC_VANILLA;
+      IsPCRel = true;
+      break;
+    }
+
+    MachO::any_relocation_info MRE;
+    MRE.r_word0 = FixupOffset;
+    MRE.r_word1 = (Writer->getSymbolAddress(*A, Layout) << 8) |
+                  (IsPCRel << 7) |
+                  (Log2Size << 5) |
+                  (false << 4) | // External
+                  (Type << 0);
+
+    Writer->addRelocation(A, Section, MRE);
+  }
+}
+} // end anonymous namespace
+
+std::unique_ptr<MCObjectTargetWriter>
+llvm::createM68kMachObjectWriter(bool Is32Bit, uint32_t CPUType,
+                                 uint32_t CPUSubtype) {
+  return std::make_unique<M68kMachObjectWriter>(Is32Bit, CPUType, CPUSubtype);
+}